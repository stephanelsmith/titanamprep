
import os,sys,re
import time
import subprocess
import shutil

from application import appwd

from application.lib.rand import randstring
from application.lib.systemstats import get_serial


def network_killall(verbose=False):
    cmd = 'airmon-ng check kill'
    if verbose:
        print cmd
    try:
        r = subprocess.check_output(cmd, shell=True).strip()
    except subprocess.CalledProcessError:
        pass
    if verbose:
        print r

def wpasupplicant_start(wlan, verbose=False):
    cmd = 'wpa_cli -i '+wlan+' status'
    try:
        r = subprocess.check_output(cmd, shell=True).strip()
    except subprocess.CalledProcessError:
        cmd = 'wpa_supplicant -B -D nl80211 -P /run/wpa_supplicant.pid -i '+wlan+' -c /etc/wpa_supplicant/wpa_supplicant.conf'
        if verbose:
            print cmd
        try:
            r = subprocess.check_output(cmd, shell=True).strip()
        except subprocess.CalledProcessError:
            pass
        if verbose:
            print r
def wpasupplicant_stop(wlan, verbose=False):
    cmd = 'wpa_cli -i '+wlan+' terminate'
    if verbose:
        print cmd
    try:
        r = subprocess.check_output(cmd, shell=True).strip()
    except subprocess.CalledProcessError:
        pass
    if verbose:
        print r



def hostapd_start(wlan, retries=5, verbose=False):
    cmd = 'systemctl daemon-reload'
    try:
        r = subprocess.check_output(cmd, shell=True).strip()
    except subprocess.CalledProcessError:
        raise

    isrunning = hostapd_isrunning(verbose=verbose)
    while retries>0 and not isrunning:
        #cmd = 'service hostapd start'
        ##cmd = 'hostapd -B /etc/hostapd/hostapd.conf'
        #try:
            #r = subprocess.check_output(cmd, shell=True).strip()
        #except subprocess.CalledProcessError:
            #raise
        #isrunning = hostapd_isrunning()
        #if isrunning:
            #return
        cmd = 'hostapd -B -P /run/hostapd.pid /etc/hostapd/hostapd.conf'
        try:
            r = subprocess.check_output(cmd, shell=True).strip()
        except subprocess.CalledProcessError:
            raise
        isrunning = hostapd_isrunning()
        if isrunning:
            return
def hostapd_stop():
    cmd = 'service hostapd stop'
    try:
        r = subprocess.check_output(cmd, shell=True).strip()
    except subprocess.CalledProcessError:
        raise
    #cmd = 'pkill hostapd'
    #try:
    #    r = subprocess.check_output(cmd, shell=True).strip()
    #except subprocess.CalledProcessError:
    #    pass
def hostapd_isrunning(verbose=False):
    #cmd = 'service hostapd status'
    cmd = 'pgrep hostapd'
    try:
        r = subprocess.check_output(cmd, shell=True).strip()
    except subprocess.CalledProcessError:
        return False
    m = re.search('(\d+)', r, re.I)
    if m:
        if verbose:
            print 'hostapd:'+str(m.group(1))
        return m.group(1)
    if verbose:
        print 'HOSTAPD NOT RUNNING'
    return False

def hostapd_writeconf(wlan, channel=7):
    template = """
#generated by titanamp
interface=wlan1
driver=nl80211
#driver=rtl871xdrv
ssid=TITANAMPf51eb7
hw_mode=g
channel=7
wmm_enabled=1
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0
wpa=2
wpa_passphrase=titanamp
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP
max_num_sta=100
ctrl_interface=/var/run/hostapd"""
    template = re.sub('^interface=wlan\d', 'interface='+wlan, template,  flags = re.I | re.M)
    template = re.sub('^channel=\d', 'channel='+str(channel), template,  flags = re.I | re.M)
    serial = get_serial()
    template = re.sub('^ssid=[\w\w\_]+', 'ssid=TitanAmp'+serial[-6:], template, flags = re.I | re.M)
    with open('/etc/hostapd/hostapd.conf', 'w') as f:
        f.write(template)





def dnsmasq_start(retries=5, verbose=False):
    isrunning = dnsmasq_isrunning(verbose=verbose)
    while retries>0 and not isrunning:
        #cmd = 'service dnsmasq start'
        cmd = 'dnsmasq'
        try:
            r = subprocess.check_output(cmd, shell=True).strip()
        except subprocess.CalledProcessError:
            dnsmasq_isrunning(verbose=True)
            raise
        isrunning = dnsmasq_isrunning(verbose=verbose)
        if not isrunning:
            print 'dnsmasq did not start...'

def dnsmasq_stop():
    cmd = 'service dnsmasq stop'
    try:
        r = subprocess.check_output(cmd, shell=True).strip()
    except subprocess.CalledProcessError:
        raise
    cmd = 'pkill dnsmasq'
    try:
        r = subprocess.check_output(cmd, shell=True).strip()
    except subprocess.CalledProcessError:
        pass

def dnsmasq_isrunning(verbose=False):
    #cmd = 'service dnsmasq status'
    cmd = 'pgrep dnsmasq'
    try:
        r = subprocess.check_output(cmd, shell=True).strip()
    except subprocess.CalledProcessError:
        return False
    m = re.search('(\d+)', r, re.I)
    if m:
        if verbose:
            print 'dnsmasq:'+str(m.group(1))
        return m.group(1)
    if verbose:
        print 'DNSMASQ NOT RUNNING'
    return False

def dnsmasq_writeconf(wlan):
    template = """
#generated by titanamp
interface=wlan1       # Use interface wlan1  
listen-address=192.168.220.1   # Specify the address to listen on  
bind-interfaces      # Bind to the interface
server=8.8.8.8       # Use Google DNS  
domain-needed        # Don't forward short names  
bogus-priv           # Drop the non-routed address spaces.  
dhcp-range=192.168.220.50,192.168.220.150,12h # IP range and lease time  
dhcp-option=3
"""
    template = re.sub('^interface=wlan\d', 'interface='+wlan, template,  flags = re.I | re.M)
    with open('/etc/dnsmasq.conf', 'w') as f:
        f.write(template)





def dhcpcd_start(retries=5, verbose=False):
    isrunning = dhcpcd_isrunning(verbose=verbose)
    while retries>0 and not isrunning:
        #cmd = 'service dhcpcd start'
        cmd = 'dhcpcd'
        try:
            r = subprocess.check_output(cmd, shell=True).strip()
        except subprocess.CalledProcessError:
            dhcpcd_isrunning(verbose=verbose)
            raise
        isrunning = dhcpcd_isrunning(verbose=verbose)
        if not isrunning:
            print 'dhcpcd did not start...'
def dhcpcd_stop():
    #cmd = 'service dhcpcd stop'
    cmd = 'pkill dhcpcd'
    try:
        r = subprocess.check_output(cmd, shell=True).strip()
    except subprocess.CalledProcessError:
        pass
def dhcpcd_release(wlan):
    cmd = 'dhcpcd --release '+wlan
    try:
        r = subprocess.check_output(cmd, shell=True).strip()
    except subprocess.CalledProcessError:
        pass
def dhcpcd_allow(wlan):
    cmd = 'dhcpcd --allowinterfaces '+wlan
    try:
        r = subprocess.check_output(cmd, shell=True).strip()
    except subprocess.CalledProcessError:
        pass
def dhcpcd_isrunning(verbose=False):
    cmd = 'service dhcpcd status'
    try:
        r = subprocess.check_output(cmd, shell=True).strip()
    except subprocess.CalledProcessError:
        return False
    if verbose:
        print r
    m = re.search('Active:\s+active', r, re.I)
    if m:
        return True
    m = re.search('Active:\s+failed', r, re.I)
    if m:
        return False
    return False
def dhcpcd_writeconf(wlan):
    defaultconf = appwd+'/'+'static/dhcpcd.conf'
    with open(defaultconf, 'r') as f:
        template = f.read()
    template = re.sub('^#interface wlan\d', 'interface '+wlan, template,  flags = re.I | re.M)
    template = re.sub('^#static ip_address=192\.168\.220\.1', r'static ip_address=192.168.220.1', template,  flags = re.I | re.M)
    template = re.sub('^#static routers=192\.168\.220\.0', r'static routers=192.168.220.0', template,  flags = re.I | re.M)
    #print template
    with open('/etc/dhcpcd.conf', 'w') as f:
        f.write(template)
    cmd = 'systemctl daemon-reload'
    try:
        r = subprocess.check_output(cmd, shell=True).strip()
    except subprocess.CalledProcessError:
        raise
def dhcpcd_revertconf():
    defaultconf = appwd+'/'+'static/dhcpcd.conf'
    shutil.copyfile(defaultconf, '/etc/dhcpcd.conf')






def iptables_conf(wifiwlan, hostwlan, verbose=False):
    cmds = [
        'iptables -F',
        'iptables -X',
        'iptables -t nat -A POSTROUTING -o '+wifiwlan+' -j MASQUERADE',
        'iptables -A FORWARD -i '+wifiwlan+' -o '+hostwlan+' -m state --state RELATED,ESTABLISHED -j ACCEPT',
        'iptables -A FORWARD -i '+hostwlan+' -o '+wifiwlan+' -j ACCEPT',
    ]
    for cmd in cmds:
        if verbose:
            print cmd
        try:
            r = subprocess.check_output(cmd, shell=True).strip()
        except subprocess.CalledProcessError:
            raise







def hostservice_connect_ipwait(wlan, verbose=False):
    loop = 30
    while hostservice_get_ip(wlan=wlan, verbose=verbose)==None and loop>0:
        time.sleep(1)
        loop -= 1
        print loop,
    if hostservice_get_ip(wlan, verbose=verbose)!=None:
        return True
    return False

def hostservice_get_ip(wlan, verbose=False):
    cmd = 'ifconfig '+wlan
    try:
        r = subprocess.check_output(cmd, shell=True).strip()
    except subprocess.CalledProcessError:
        raise
    ip_address = None
    if verbose:
        print r
    for line in r.split('\n'):
        m = re.match('\s*inet addr:(?P<ip_address>[\d\.]+)', line, re.I)
        if m:
            ip_address = m.group('ip_address')
    return ip_address

#hostapd_cli -i wlan1 all_sta
def hostservice_get_stas(wlan):
    cmd = 'hostapd_cli -i '+wlan+' all_sta'
    try:
        r = subprocess.check_output(cmd, shell=True).strip()
    except subprocess.CalledProcessError:
        raise
    stas = []
    for line in r.split('\n'):
        m = re.match('(?P<sta>\w\w:\w\w:\w\w:\w\w:\w\w:\w\w)', line, re.I)
        if m:
            stas.append(m.group('sta'))
    return stas

#hostapd_cli -i wlan1 get_config
def hostservice_get_ssid(wlan):
    cmd = 'hostapd_cli -i '+wlan+' get_config'
    try:
        r = subprocess.check_output(cmd, shell=True).strip()
    except subprocess.CalledProcessError:
        raise
    ssid = None
    for line in r.split('\n'):
        m = re.match('ssid=(?P<ssid>[\w\_\-]+)', line, re.I)
        if m:
            ssid = m.group('ssid')
    return ssid



